#!/usr/bin/env bash
# rite - Sharkrite CLI for automated GitHub workflows
# Smart dispatcher that routes to appropriate workflow
#
# Usage:
#   rite <issue>              Process single issue (full lifecycle)
#   rite <issue1> <issue2>    Process multiple issues (batch)
#   rite <issue> --quick      Work + PR only, skip review/merge
#   rite <issue> --undo       Undo workflow: close PR, clean up artifacts
#   rite --followup           Auto-discover follow-up pairs
#   rite --init               Initialize .rite/ in current project
#   rite --dry-run <...>      Print execution plan without running

set -euo pipefail

VERSION="2.0.0"

# Resolve symlink chain to get actual install location
SCRIPT_PATH="${BASH_SOURCE[0]}"
while [ -L "$SCRIPT_PATH" ]; do
  SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
  SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
  [[ $SCRIPT_PATH != /* ]] && SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_PATH"
done
RITE_INSTALL_DIR="$(cd "$(dirname "$SCRIPT_PATH")/.." && pwd)"
RITE_LIB_DIR="$RITE_INSTALL_DIR/lib"
export RITE_INSTALL_DIR RITE_LIB_DIR

# Parse --dry-run early (before config, so config respects it)
for arg in "$@"; do
  if [ "$arg" = "--dry-run" ]; then
    export RITE_DRY_RUN=true
  fi
done

# Source configuration (detects project, loads configs)
source "$RITE_LIB_DIR/utils/config.sh"
source "$RITE_LIB_DIR/utils/colors.sh"

# Default mode: full lifecycle (workflow-runner)
MODE="full"
RITE_LOG_FILE="${RITE_LOG_FILE:-}"
RITE_LOG_AUTO=true  # Logging on by default

# Parse args and detect intent
ARGS=()
WORKFLOW_FLAGS=()
FILTER=""
SUPERVISED=false
while [[ $# -gt 0 ]]; do
  case $1 in
    --quick)
      MODE="quick"
      shift
      ;;
    --undo)
      MODE="undo"
      shift
      ;;
    --supervised)
      SUPERVISED=true
      WORKFLOW_FLAGS+=("--supervised")
      shift
      ;;
    --auto)
      WORKFLOW_FLAGS+=("--auto")
      shift
      ;;
    --bypass-blockers)
      WORKFLOW_FLAGS+=("--bypass-blockers")
      shift
      ;;
    --followup)
      MODE="batch"
      FILTER="--followup"
      shift
      ;;
    --log)
      RITE_LOG_AUTO=true  # Explicit enable (already default, here for clarity)
      shift
      ;;
    --no-log)
      RITE_LOG_AUTO=false
      shift
      ;;
    --log=*)
      RITE_LOG_FILE="${1#--log=}"
      shift
      ;;
    --pr)
      # Run by PR number instead of issue number
      if [ -z "${2:-}" ] || [[ "$2" == -* ]]; then
        print_error "--pr requires a PR number"
        exit 1
      fi
      PR_INPUT="$2"
      shift 2
      ;;
    --dry-run)
      # Already parsed above
      shift
      ;;
    --init)
      MODE="init"
      shift
      ;;
    --version|-v)
      echo "rite version $VERSION"
      exit 0
      ;;
    --help|-h)
      echo "rite - Sharkrite CLI v${VERSION}"
      echo "Automate GitHub issues with Claude Code"
      echo ""
      echo "Usage:"
      echo "  rite <issue>              Process single issue (unsupervised, default)"
      echo "  rite <issue> --supervised Process single issue (supervised, bypasses blockers)"
      echo "  rite <issue1> <issue2>    Process multiple issues (batch)"
      echo "  rite <issue> --quick      Work + PR only, skip review/merge"
      echo "  rite <issue> --undo       Undo workflow: close PR, clean up artifacts"
      echo "  rite --pr <number>        Run by PR number (resolves linked issue)"
      echo "  rite --followup           Security debt report + batch process"
      echo "  rite --init               Initialize .rite/ in current project"
      echo "  rite --dry-run <...>      Print execution plan without running"
      echo "  rite <issue> --no-log     Full lifecycle without logging (logs are on by default)"
      echo ""
      echo "Workflow flags:"
      echo "  --supervised               Supervised mode (approve hard gates interactively)"
      echo "  --bypass-blockers          Skip hard gates in unsupervised mode (CRITICAL findings, session limits)"
      echo "  --no-log                   Disable logging (logs are on by default)"
      echo "  --log=FILE                 Log to a specific file instead of auto-generated path"
      echo ""
      echo "Project: $RITE_PROJECT_NAME"
      echo "Root:    $RITE_PROJECT_ROOT"
      echo "Config:  $RITE_PROJECT_ROOT/$RITE_DATA_DIR/config"
      echo ""
      echo "Examples:"
      echo "  rite 21                   # Full lifecycle (unsupervised, default)"
      echo "  rite 21 --supervised      # Supervised: approve hard gates interactively"
      echo "  rite 21 --bypass-blockers # Skip hard gates (CRITICAL findings, session limits)"
      echo "  rite 21 45                # Batch process issues"
      echo "  rite 21 --quick           # Quick mode: work + PR only"
      echo "  rite 21 --undo            # Undo: close PR, clean branches/worktree/state"
      echo "  rite --pr 72              # Run by PR number"
      echo "  rite --followup           # Process tech-debt issues"
      echo "  rite 21 --dry-run         # See what would happen"
      echo ""
      echo "Sharkrite - Master your workflows."
      exit 0
      ;;
    -*)
      print_error "Unknown flag: $1"
      exit 1
      ;;
    *)
      ARGS+=("$1")
      shift
      ;;
  esac
done

# Set up logging (on by default, --no-log to disable)
if [ "$RITE_LOG_AUTO" = true ] && [ -z "$RITE_LOG_FILE" ]; then
  LOG_ISSUE="${ARGS[0]:-session}"
  LOG_TIMESTAMP=$(date '+%Y%m%d-%H%M%S')

  # Log filename keyed by issue number. When the arg is a description string
  # (not yet an issue number), use "new" — the issue gets created later.
  if [[ "$LOG_ISSUE" =~ ^[0-9]+$ ]]; then
    LOG_SLUG="$LOG_ISSUE"
  else
    LOG_SLUG="new"
  fi
  RITE_LOG_FILE="$RITE_PROJECT_ROOT/$RITE_DATA_DIR/logs/rite-${LOG_SLUG}-${LOG_TIMESTAMP}.log"

  # Auto-prune: keep last 20 logs, delete older ones
  RITE_LOG_DIR="$RITE_PROJECT_ROOT/$RITE_DATA_DIR/logs"
  if [ -d "$RITE_LOG_DIR" ]; then
    LOG_COUNT=$(ls -1 "$RITE_LOG_DIR"/rite-*.log 2>/dev/null | wc -l | tr -d ' ') || true
    if [ "$LOG_COUNT" -gt 20 ]; then
      ls -1t "$RITE_LOG_DIR"/rite-*.log 2>/dev/null | tail -n +21 | xargs rm -f 2>/dev/null || true
    fi
  fi
fi

if [ -n "$RITE_LOG_FILE" ]; then
  mkdir -p "$(dirname "$RITE_LOG_FILE")"

  # Write log header
  {
    echo "=== Sharkrite Log ==="
    echo "Date: $(date '+%Y-%m-%d %H:%M:%S')"
    echo "Command: rite ${ARGS[*]:-} (mode=$MODE)"
    echo "Project: ${RITE_PROJECT_NAME:-unknown}"
    echo "Version: $VERSION"
    echo "==="
    echo ""
  } > "$RITE_LOG_FILE"

  # Single tee for both stdout and stderr to avoid log interleaving.
  # Two separate tee processes (one per fd) race when appending to the same file,
  # causing non-deterministic output ordering. Merging stderr into the tee'd stdout
  # ensures all output flows through one pipe and arrives in execution order.
  exec > >(tee >(strip_ansi >> "$RITE_LOG_FILE"))
  exec 2>&1

  export RITE_LOG_FILE
  print_info "Logging to: $RITE_LOG_FILE"
fi

# Handle init mode
if [ "$MODE" = "init" ]; then
  print_header "Initializing Sharkrite for $RITE_PROJECT_NAME"

  # Create .rite/ directory structure
  mkdir -p "$RITE_PROJECT_ROOT/$RITE_DATA_DIR"

  # Copy templates
  if [ ! -f "$RITE_PROJECT_ROOT/$RITE_DATA_DIR/config" ]; then
    cp "$RITE_INSTALL_DIR/config/project.conf.example" "$RITE_PROJECT_ROOT/$RITE_DATA_DIR/config"
    print_success "Created .rite/config"
  else
    print_info ".rite/config already exists, skipping"
  fi

  if [ ! -f "$RITE_PROJECT_ROOT/$RITE_DATA_DIR/blockers.conf" ]; then
    cp "$RITE_INSTALL_DIR/config/blockers.conf.example" "$RITE_PROJECT_ROOT/$RITE_DATA_DIR/blockers.conf"
    print_success "Created .rite/blockers.conf"
  else
    print_info ".rite/blockers.conf already exists, skipping"
  fi

  if [ ! -f "$RITE_PROJECT_ROOT/$RITE_DATA_DIR/scratch.md" ]; then
    cp "$RITE_INSTALL_DIR/templates/scratchpad.md" "$RITE_PROJECT_ROOT/$RITE_DATA_DIR/scratch.md"
    print_success "Created .rite/scratch.md"
  else
    print_info ".rite/scratch.md already exists, skipping"
  fi

  if [ ! -f "$RITE_PROJECT_ROOT/$RITE_DATA_DIR/.gitignore" ]; then
    cp "$RITE_INSTALL_DIR/templates/gitignore" "$RITE_PROJECT_ROOT/$RITE_DATA_DIR/.gitignore"
    print_success "Created .rite/.gitignore"
  else
    print_info ".rite/.gitignore already exists, skipping"
  fi

  # Create backward-compat symlink if .claude/ exists
  if [ -d "$RITE_PROJECT_ROOT/.claude" ] && [ ! -e "$RITE_PROJECT_ROOT/.claude/scratch.md" ]; then
    ln -sf "../$RITE_DATA_DIR/scratch.md" "$RITE_PROJECT_ROOT/.claude/scratch.md"
    print_success "Created .claude/scratch.md symlink for backward compatibility"
  fi

  print_success "Sharkrite initialized for $RITE_PROJECT_NAME"

  # ─────────────────────────────────────────────────────────────────
  # GitHub Workflow Setup (optional)
  # ─────────────────────────────────────────────────────────────────

  echo ""
  print_info "GitHub Workflow Setup"

  # Note: The GitHub Actions auto-review workflow (claude-code-review.yml) is
  # deprecated. Sharkrite uses local reviews via local-review.sh instead.
  # The @claude interactive workflow is still supported.
  if [ -f ".github/workflows/claude-code-review.yml" ]; then
    print_warning "Found deprecated claude-code-review.yml workflow"
    print_info "Sharkrite now uses local reviews — this GitHub Actions workflow can be removed"
  fi

  if [ ! -f ".github/workflows/claude.yml" ]; then
    echo ""
    read -p "Enable @claude mentions in issues/PRs? (y/n) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
      mkdir -p .github/workflows
      cp "$RITE_INSTALL_DIR/templates/github/workflows/claude-interactive.yml" .github/workflows/claude.yml
      print_success "Created .github/workflows/claude.yml"
    fi
  else
    print_success "@claude interactive workflow already exists"
  fi

  # Ensure review instructions exist (used by local-review.sh)
  if [ ! -f ".github/claude-code/pr-review-instructions.md" ]; then
    mkdir -p .github/claude-code
    cp "$RITE_INSTALL_DIR/templates/github/claude-code/pr-review-instructions.md" .github/claude-code/
    print_success "Created .github/claude-code/pr-review-instructions.md"
  fi

  # Optional: Merge notifications
  if [ ! -f ".github/workflows/pr-merged-notification.yml" ]; then
    echo ""
    read -p "Send Slack notifications on PR merge? (y/n) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
      mkdir -p .github/workflows
      cp "$RITE_INSTALL_DIR/templates/github/workflows/pr-merged-notification.yml" .github/workflows/
      print_success "Created .github/workflows/pr-merged-notification.yml"
      print_info "Add SLACK_WEBHOOK secret to enable notifications"
    fi
  fi

  # Optional: PR template
  if [ ! -f ".github/PULL_REQUEST_TEMPLATE.md" ]; then
    echo ""
    read -p "Create PR template? (y/n) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
      mkdir -p .github
      cp "$RITE_INSTALL_DIR/templates/github/PULL_REQUEST_TEMPLATE.md" .github/
      print_success "Created .github/PULL_REQUEST_TEMPLATE.md"
    fi
  fi

  echo ""
  print_info "Next steps:"
  echo "  1. Edit .rite/config with project-specific settings"
  echo "  2. Edit .rite/blockers.conf to customize blocker path patterns"
  echo "  3. Run 'rite 21' to process your first issue"
  echo ""
  exit 0
fi

# Source normalization utilities
source "$RITE_LIB_DIR/utils/normalize-issue.sh"

# Normalize and resolve issue input.
# Runs in the MAIN shell (not a subshell) so NORMALIZED_SUBJECT, WORK_DESCRIPTION,
# ISSUE_NUMBER, and ISSUE_DESC are available to the calling scope.
#
# For numeric input: fetches issue details from GitHub, applies bash cleanup to title.
# For text input: uses Claude to generate a structured issue, prompts for approval.
normalize_and_resolve() {
  local input="$1"

  if [[ "$input" =~ ^[0-9]+$ ]]; then
    # Pre-existing issue — fetch details, then normalize title
    ISSUE_NUMBER="$input"

    ISSUE_JSON=$(gh issue view "$ISSUE_NUMBER" --json title,body,state 2>/dev/null || echo "")
    if [ -z "$ISSUE_JSON" ] || [ "$ISSUE_JSON" = "null" ]; then
      print_error "Issue #$ISSUE_NUMBER not found on GitHub"
      exit 1
    fi

    ISSUE_DESC=$(echo "$ISSUE_JSON" | jq -r '.title')
    ISSUE_BODY=$(echo "$ISSUE_JSON" | jq -r '.body // ""')
    local issue_state
    issue_state=$(echo "$ISSUE_JSON" | jq -r '.state')

    if [ -z "$ISSUE_DESC" ] || [ "$ISSUE_DESC" = "null" ]; then
      print_error "Issue #$ISSUE_NUMBER has no title"
      exit 1
    fi

    if [ "$issue_state" = "CLOSED" ]; then
      print_warning "Issue #$ISSUE_NUMBER is already CLOSED — proceeding anyway"
    fi

    normalize_existing_issue  # Sets NORMALIZED_SUBJECT, WORK_DESCRIPTION
  else
    # Text description — generate structured issue via Claude, prompt for approval
    if ! normalize_piped_input "$input"; then
      exit 1
    fi
    # normalize_piped_input sets: ISSUE_NUMBER, ISSUE_DESC, NORMALIZED_SUBJECT,
    # WORK_DESCRIPTION, GENERATED_ISSUE_BODY
  fi

  export ISSUE_NUMBER ISSUE_DESC NORMALIZED_SUBJECT WORK_DESCRIPTION
}

# Pre-flight: check Claude CLI is available (not needed for --undo)
if [ "$MODE" != "undo" ]; then
  if ! command -v claude &>/dev/null && ! command -v claude-code &>/dev/null; then
    print_error "Claude CLI not found"
    echo ""
    echo "Sharkrite requires Claude Code to run workflows."
    echo "Install it with: npm install -g @anthropic-ai/claude-code"
    echo "Then authenticate: claude"
    echo ""
    exit 1
  fi
fi

# Pre-flight: check gh CLI and auth
if ! command -v gh &>/dev/null; then
  print_error "GitHub CLI (gh) not found"
  echo ""
  echo "Sharkrite requires the GitHub CLI."
  echo "Install it with: brew install gh"
  echo "Then authenticate: gh auth login"
  echo ""
  exit 1
fi

if ! gh auth status &>/dev/null; then
  print_error "GitHub CLI not authenticated"
  echo ""
  echo "Run: gh auth login"
  echo ""
  exit 1
fi

# Resolve --pr to issue number
if [ -n "${PR_INPUT:-}" ]; then
  print_status "Resolving PR #$PR_INPUT to linked issue..."
  PR_BODY=$(gh pr view "$PR_INPUT" --json body --jq '.body' 2>/dev/null || echo "")
  if [ -z "$PR_BODY" ]; then
    print_error "Could not fetch PR #$PR_INPUT"
    exit 1
  fi
  LINKED_ISSUE=$(echo "$PR_BODY" | grep -oE '(Closes|closes|Fixes|fixes|Resolves|resolves) #[0-9]+' | head -1 | grep -oE '[0-9]+' || echo "")
  if [ -z "$LINKED_ISSUE" ]; then
    print_error "PR #$PR_INPUT has no linked issue (expected 'Closes #N' in body)"
    exit 1
  fi
  print_success "PR #$PR_INPUT → issue #$LINKED_ISSUE"
  ARGS=("$LINKED_ISSUE")
fi

# Smart routing
if [ ${#ARGS[@]} -eq 0 ] && [ -z "$FILTER" ]; then
  print_error "No issues specified"
  echo "Run 'rite --help' for usage"
  exit 1
elif [ ${#ARGS[@]} -eq 1 ] && [ "$MODE" = "full" ]; then
  normalize_and_resolve "${ARGS[0]}"
  # Full lifecycle: work -> PR -> review -> fixes -> merge
  # Default to unsupervised (--auto) unless --supervised was explicitly passed
  if [ "$SUPERVISED" = false ]; then
    exec "$RITE_LIB_DIR/core/workflow-runner.sh" "$ISSUE_NUMBER" --auto "${WORKFLOW_FLAGS[@]+"${WORKFLOW_FLAGS[@]}"}"
  else
    exec "$RITE_LIB_DIR/core/workflow-runner.sh" "$ISSUE_NUMBER" "${WORKFLOW_FLAGS[@]+"${WORKFLOW_FLAGS[@]}"}"
  fi
elif [ ${#ARGS[@]} -eq 1 ] && [ "$MODE" = "quick" ]; then
  # Normalize and resolve (runs in main shell)
  normalize_and_resolve "${ARGS[0]}"
  # Quick mode: work -> PR only (skip review wait and merge)
  print_info "Quick mode: issue #${ISSUE_NUMBER} (work + PR, skip review/merge)"
  "$RITE_LIB_DIR/core/claude-workflow.sh" "$ISSUE_NUMBER" --auto
  "$RITE_LIB_DIR/core/create-pr.sh" --auto
  print_success "Quick mode complete — PR created, skipping review/merge"
  exit 0
elif [ "$MODE" = "undo" ] && [ ${#ARGS[@]} -ne 1 ]; then
  print_error "--undo requires exactly one issue number"
  echo "Usage: rite <issue> --undo"
  exit 1
elif [ ${#ARGS[@]} -eq 1 ] && [ "$MODE" = "undo" ]; then
  # Undo mode: no normalization needed, just validate and pass through
  if [[ ! "${ARGS[0]}" =~ ^[0-9]+$ ]]; then
    print_error "--undo requires an issue number, not a description"
    exit 1
  fi
  exec "$RITE_LIB_DIR/core/undo-workflow.sh" "${ARGS[0]}"
elif [ ${#ARGS[@]} -gt 1 ] || [ -n "$FILTER" ]; then
  # Batch mode
  print_info "Batch processing ${#ARGS[@]} issues"
  exec "$RITE_LIB_DIR/core/batch-process-issues.sh" "${ARGS[@]}" ${FILTER} --auto
fi
