#!/usr/bin/env bash
# rite - Sharkrite CLI for automated GitHub workflows
# Smart dispatcher that routes to appropriate workflow
#
# Usage:
#   rite <issue>              Process single issue (full lifecycle)
#   rite <issue1> <issue2>    Process multiple issues (batch)
#   rite <issue> --quick      Work + PR only, skip review/merge
#   rite --followup           Auto-discover follow-up pairs
#   rite --init               Initialize .rite/ in current project
#   rite --dry-run <...>      Print execution plan without running

set -euo pipefail

VERSION="2.0.0"

# Resolve symlink chain to get actual install location
SCRIPT_PATH="${BASH_SOURCE[0]}"
while [ -L "$SCRIPT_PATH" ]; do
  SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
  SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
  [[ $SCRIPT_PATH != /* ]] && SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_PATH"
done
RITE_INSTALL_DIR="$(cd "$(dirname "$SCRIPT_PATH")/.." && pwd)"
RITE_LIB_DIR="$RITE_INSTALL_DIR/lib"
export RITE_INSTALL_DIR RITE_LIB_DIR

# Parse --dry-run early (before config, so config respects it)
for arg in "$@"; do
  if [ "$arg" = "--dry-run" ]; then
    export RITE_DRY_RUN=true
  fi
done

# Source configuration (detects project, loads configs)
source "$RITE_LIB_DIR/utils/config.sh"
source "$RITE_LIB_DIR/utils/colors.sh"

# Default mode: full lifecycle (workflow-runner)
MODE="full"

# Parse args and detect intent
ARGS=()
WORKFLOW_FLAGS=()
FILTER=""
SUPERVISED=false
while [[ $# -gt 0 ]]; do
  case $1 in
    --quick)
      MODE="quick"
      shift
      ;;
    --supervised)
      SUPERVISED=true
      WORKFLOW_FLAGS+=("--supervised")
      shift
      ;;
    --auto)
      WORKFLOW_FLAGS+=("--auto")
      shift
      ;;
    --bypass-blockers)
      WORKFLOW_FLAGS+=("--bypass-blockers")
      shift
      ;;
    --followup)
      MODE="batch"
      FILTER="--followup"
      shift
      ;;
    --dry-run)
      # Already parsed above
      shift
      ;;
    --init)
      MODE="init"
      shift
      ;;
    --version|-v)
      echo "rite version $VERSION"
      exit 0
      ;;
    --help|-h)
      echo "rite - Sharkrite CLI v${VERSION}"
      echo "Automate GitHub issues with Claude Code"
      echo ""
      echo "Usage:"
      echo "  rite <issue>              Process single issue (unsupervised, default)"
      echo "  rite <issue> --supervised Process single issue (supervised, bypasses blockers)"
      echo "  rite <issue1> <issue2>    Process multiple issues (batch)"
      echo "  rite <issue> --quick      Work + PR only, skip review/merge"
      echo "  rite --followup           Security debt report + batch process"
      echo "  rite --init               Initialize .rite/ in current project"
      echo "  rite --dry-run <...>      Print execution plan without running"
      echo ""
      echo "Workflow flags:"
      echo "  --supervised               Supervised mode (bypasses blockers with warnings)"
      echo "  --bypass-blockers          Unsupervised blocker bypass (warnings to Slack)"
      echo ""
      echo "Project: $RITE_PROJECT_NAME"
      echo "Root:    $RITE_PROJECT_ROOT"
      echo "Config:  $RITE_PROJECT_ROOT/$RITE_DATA_DIR/config"
      echo ""
      echo "Examples:"
      echo "  rite 21                   # Full lifecycle (unsupervised, default)"
      echo "  rite 21 --supervised      # Supervised: bypasses blockers with warnings"
      echo "  rite 21 --bypass-blockers # Unsupervised: bypass blockers, warn via Slack"
      echo "  rite 21 45                # Batch process issues"
      echo "  rite 21 --quick           # Quick mode: work + PR only"
      echo "  rite --followup           # Process security-debt issues"
      echo "  rite 21 --dry-run         # See what would happen"
      echo ""
      echo "Sharkrite - Master your workflows."
      exit 0
      ;;
    -*)
      print_error "Unknown flag: $1"
      exit 1
      ;;
    *)
      ARGS+=("$1")
      shift
      ;;
  esac
done

# Handle init mode
if [ "$MODE" = "init" ]; then
  print_header "Initializing Sharkrite for $RITE_PROJECT_NAME"

  # Create .rite/ directory structure
  mkdir -p "$RITE_PROJECT_ROOT/$RITE_DATA_DIR"

  # Copy templates
  if [ ! -f "$RITE_PROJECT_ROOT/$RITE_DATA_DIR/config" ]; then
    cp "$RITE_INSTALL_DIR/config/project.conf.example" "$RITE_PROJECT_ROOT/$RITE_DATA_DIR/config"
    print_success "Created .rite/config"
  else
    print_info ".rite/config already exists, skipping"
  fi

  if [ ! -f "$RITE_PROJECT_ROOT/$RITE_DATA_DIR/blockers.conf" ]; then
    cp "$RITE_INSTALL_DIR/config/blockers.conf.example" "$RITE_PROJECT_ROOT/$RITE_DATA_DIR/blockers.conf"
    print_success "Created .rite/blockers.conf"
  else
    print_info ".rite/blockers.conf already exists, skipping"
  fi

  if [ ! -f "$RITE_PROJECT_ROOT/$RITE_DATA_DIR/scratch.md" ]; then
    cp "$RITE_INSTALL_DIR/templates/scratchpad.md" "$RITE_PROJECT_ROOT/$RITE_DATA_DIR/scratch.md"
    print_success "Created .rite/scratch.md"
  else
    print_info ".rite/scratch.md already exists, skipping"
  fi

  if [ ! -f "$RITE_PROJECT_ROOT/$RITE_DATA_DIR/.gitignore" ]; then
    cp "$RITE_INSTALL_DIR/templates/gitignore" "$RITE_PROJECT_ROOT/$RITE_DATA_DIR/.gitignore"
    print_success "Created .rite/.gitignore"
  else
    print_info ".rite/.gitignore already exists, skipping"
  fi

  # Create backward-compat symlink if .claude/ exists
  if [ -d "$RITE_PROJECT_ROOT/.claude" ] && [ ! -e "$RITE_PROJECT_ROOT/.claude/scratch.md" ]; then
    ln -sf "../$RITE_DATA_DIR/scratch.md" "$RITE_PROJECT_ROOT/.claude/scratch.md"
    print_success "Created .claude/scratch.md symlink for backward compatibility"
  fi

  print_success "Sharkrite initialized for $RITE_PROJECT_NAME"

  # ─────────────────────────────────────────────────────────────────
  # GitHub Workflow Setup (optional)
  # ─────────────────────────────────────────────────────────────────

  echo ""
  print_info "GitHub Workflow Setup"

  if [ -d ".github/workflows" ] && [ -f ".github/workflows/claude-code-review.yml" ]; then
    print_success "Claude Code review workflow already exists"

    # Check for permission issues
    if grep -q "pull-requests: read" .github/workflows/claude-code-review.yml 2>/dev/null; then
      print_warning "Workflow may have permission issues"
      print_info "Change 'pull-requests: read' to 'pull-requests: write' for comments to work"
    fi
  else
    echo ""
    read -p "Set up Claude Code review workflow? (y/n) " -n 1 -r
    echo

    if [[ $REPLY =~ ^[Yy]$ ]]; then
      # Create directories
      mkdir -p .github/workflows
      mkdir -p .github/claude-code

      # Copy core review workflow and instructions
      cp "$RITE_INSTALL_DIR/templates/github/workflows/claude-code-review.yml" .github/workflows/
      cp "$RITE_INSTALL_DIR/templates/github/claude-code/pr-review-instructions.md" .github/claude-code/
      print_success "Created .github/workflows/claude-code-review.yml"
      print_success "Created .github/claude-code/pr-review-instructions.md"

      # Optional: Interactive @claude workflow
      echo ""
      read -p "Enable @claude mentions in issues/PRs? (y/n) " -n 1 -r
      echo
      if [[ $REPLY =~ ^[Yy]$ ]]; then
        cp "$RITE_INSTALL_DIR/templates/github/workflows/claude-interactive.yml" .github/workflows/claude.yml
        print_success "Created .github/workflows/claude.yml"
      fi

      # Optional: Merge notifications
      echo ""
      read -p "Send Slack notifications on PR merge? (y/n) " -n 1 -r
      echo
      if [[ $REPLY =~ ^[Yy]$ ]]; then
        cp "$RITE_INSTALL_DIR/templates/github/workflows/pr-merged-notification.yml" .github/workflows/
        print_success "Created .github/workflows/pr-merged-notification.yml"
        print_info "Add SLACK_WEBHOOK secret to enable notifications"
      fi

      # Copy README
      cp "$RITE_INSTALL_DIR/templates/github/README.md" .github/

      # Optional: PR template
      if [ ! -f ".github/PULL_REQUEST_TEMPLATE.md" ]; then
        echo ""
        read -p "Create PR template? (y/n) " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
          cp "$RITE_INSTALL_DIR/templates/github/PULL_REQUEST_TEMPLATE.md" .github/
          print_success "Created .github/PULL_REQUEST_TEMPLATE.md"
        fi
      fi

      # ─────────────────────────────────────────────────────────────
      # Codebase Scan (future: theme detection)
      # ─────────────────────────────────────────────────────────────

      echo ""
      print_info "Theme Detection (coming soon)"
      print_info "Future versions will scan your codebase to customize review instructions"
      print_info "with project-specific checks (multi-tenant, AWS, compliance, etc.)"

      # Placeholder for future scan logic:
      # echo ""
      # read -p "Scan codebase to customize review instructions? (y/n) " -n 1 -r
      # echo
      # if [[ $REPLY =~ ^[Yy]$ ]]; then
      #   source "$RITE_LIB_DIR/utils/theme-scanner.sh"
      #   scan_and_append_themes
      # fi

      # ─────────────────────────────────────────────────────────────
      # Setup Instructions
      # ─────────────────────────────────────────────────────────────

      echo ""
      echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
      print_warning "Manual setup required:"
      echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
      echo ""
      echo "  1. Get OAuth token:"
      echo "     claude auth login --github"
      echo ""
      echo "  2. Add secret to repo:"
      echo "     Settings > Secrets > Actions > New repository secret"
      echo "     Name: CLAUDE_CODE_OAUTH_TOKEN"
      echo "     Value: [paste token]"
      echo ""
      if [[ -f ".github/workflows/pr-merged-notification.yml" ]]; then
        echo "  3. (Optional) Add SLACK_WEBHOOK secret for merge notifications"
        echo ""
      fi
      echo "  Customize review criteria:"
      echo "     .github/claude-code/pr-review-instructions.md"
      echo ""
      echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    fi
  fi

  echo ""
  print_info "Next steps:"
  echo "  1. Edit .rite/config with project-specific settings"
  echo "  2. Edit .rite/blockers.conf to customize blocker path patterns"
  echo "  3. Run 'rite 21' to process your first issue"
  echo ""
  exit 0
fi

# Resolve a text description to an issue number by creating a GitHub issue
resolve_or_create_issue() {
  local input="$1"

  # Already a number — return as-is
  if [[ "$input" =~ ^[0-9]+$ ]]; then
    echo "$input"
    return 0
  fi

  # Text description — create a GitHub issue
  print_info "Creating GitHub issue from description..." >&2
  local issue_url
  issue_url=$(gh issue create --title "$input" --body "Created by rite from CLI description." 2>&1)
  if [ $? -ne 0 ]; then
    print_error "Failed to create GitHub issue: $issue_url" >&2
    exit 1
  fi

  # Extract issue number from URL (e.g., https://github.com/owner/repo/issues/42)
  local issue_number
  issue_number=$(echo "$issue_url" | grep -oE '[0-9]+$')
  if [ -z "$issue_number" ]; then
    print_error "Could not extract issue number from: $issue_url" >&2
    exit 1
  fi

  print_success "Created issue #${issue_number}: ${input}" >&2
  echo "$issue_number"
}

# Pre-flight: check Claude CLI is available
if ! command -v claude &>/dev/null && ! command -v claude-code &>/dev/null; then
  print_error "Claude CLI not found"
  echo ""
  echo "Sharkrite requires Claude Code to run workflows."
  echo "Install it with: npm install -g @anthropic-ai/claude-code"
  echo "Then authenticate: claude"
  echo ""
  exit 1
fi

# Pre-flight: check gh CLI and auth
if ! command -v gh &>/dev/null; then
  print_error "GitHub CLI (gh) not found"
  echo ""
  echo "Sharkrite requires the GitHub CLI."
  echo "Install it with: brew install gh"
  echo "Then authenticate: gh auth login"
  echo ""
  exit 1
fi

if ! gh auth status &>/dev/null; then
  print_error "GitHub CLI not authenticated"
  echo ""
  echo "Run: gh auth login"
  echo ""
  exit 1
fi

# Smart routing
if [ ${#ARGS[@]} -eq 0 ] && [ -z "$FILTER" ]; then
  print_error "No issues specified"
  echo "Run 'rite --help' for usage"
  exit 1
elif [ ${#ARGS[@]} -eq 1 ] && [ "$MODE" = "full" ]; then
  # Resolve text descriptions to issue numbers
  ISSUE_NUMBER=$(resolve_or_create_issue "${ARGS[0]}")
  # Full lifecycle: work -> PR -> review -> fixes -> merge
  # Default to unsupervised (--auto) unless --supervised was explicitly passed
  if [ "$SUPERVISED" = false ]; then
    exec "$RITE_LIB_DIR/core/workflow-runner.sh" "$ISSUE_NUMBER" --auto "${WORKFLOW_FLAGS[@]+"${WORKFLOW_FLAGS[@]}"}"
  else
    exec "$RITE_LIB_DIR/core/workflow-runner.sh" "$ISSUE_NUMBER" "${WORKFLOW_FLAGS[@]+"${WORKFLOW_FLAGS[@]}"}"
  fi
elif [ ${#ARGS[@]} -eq 1 ] && [ "$MODE" = "quick" ]; then
  # Resolve text descriptions to issue numbers
  ISSUE_NUMBER=$(resolve_or_create_issue "${ARGS[0]}")
  # Quick mode: work -> PR only (skip review wait and merge)
  print_info "Quick mode: issue #${ISSUE_NUMBER} (work + PR, skip review/merge)"
  "$RITE_LIB_DIR/core/claude-workflow.sh" "$ISSUE_NUMBER" --auto
  "$RITE_LIB_DIR/core/create-pr.sh" --auto
  print_success "Quick mode complete — PR created, skipping review/merge"
  exit 0
elif [ ${#ARGS[@]} -gt 1 ] || [ -n "$FILTER" ]; then
  # Batch mode
  print_info "Batch processing ${#ARGS[@]} issues"
  exec "$RITE_LIB_DIR/core/batch-process-issues.sh" "${ARGS[@]}" ${FILTER} --auto
fi
